import * as vscode from "vscode";

import { insertSnippet, getActivePosition, getCurrentFileText, getCurOffsetByPosition } from "./utils/vscode";
import { getCompletionItemsByContextText } from "./intellisense";
import { IntellisenseCommandArguments } from "./types/intellisense";
import { Snippet } from "./types/snippet";
import { insertEffectPatches } from "./utils/effects";
import { getLineAndCharacterNumFromOffset } from "./utils/utils";
import { CodeRange } from "./types/common";

/**
 * Here is how fly-snippet runs:
 * 1. The snippet codes are eventually generated by a series of intellisense operations.
 *
 * 2. There are two types of intellisense: search-intellisense & options-intellisense.
 *    The former is for searching the snippet like: 'a.b.c.xxx' you need and the later is for selecting or unselecting the options which would add more details to the final snippet.
 *
 * 3. So the complete intellisense process is:
 *    search-intellisense1 -> search-intellisense2 -> ... -> search-intellisenseN -> options-intellisense(if has) -> snippet codes
 */

function correctOffsetByCodeRanges(offset: number, codeRanges: CodeRange[]) {
  let newOffset = offset;
  for (const cr of codeRanges) {
    const { offset: codeOffset = 0, len = 0 } = cr;
    if (codeOffset + len < offset) {
      newOffset += len;
    }
  }
  return newOffset;
}

async function insertSnippets(
  snippet: Snippet,
  start: vscode.Position | undefined,
  end: vscode.Position | undefined
) {
  if (!start || !end) {
    return;
  }
  const { tpl, variables, effectPatches = [], genSnippetFn } = snippet;

  // 1. insert snippet
  const target = genSnippetFn(tpl, variables); // run the `genSnippetFn` to get the final snippet `target`
  await insertSnippet(start, end, target);

  // 2. record the target inserted position
  const targetPos = getActivePosition();
  const targetOffset = getCurOffsetByPosition(targetPos as vscode.Position); // trans the position to offset

  // 3. inert effects snippets
  // store all `CodeRange` after effects insertion, use them to correct `targetOffset`
  const effectCodeRanges: CodeRange[] = [];
  const codeRangeAdder = (cr: CodeRange) => effectCodeRanges.push(cr);
  let codeStr = getCurrentFileText();
  await insertEffectPatches(codeStr, effectPatches || [], codeRangeAdder);
  
  // 4. correct the target inserted position by `effectCodeRanges`
  const newTargetOffset = correctOffsetByCodeRanges(targetOffset, effectCodeRanges);

  // 5. change current cursor to new inserted position and focus on it
  codeStr = getCurrentFileText();
  const [line, character] = getLineAndCharacterNumFromOffset(codeStr, newTargetOffset);
  const cur = new vscode.Position(line, character);
  const editor = vscode.window.activeTextEditor || {};
  (editor as any).selection = new vscode.Selection(cur, cur); // change the cursor
  (editor as any).revealRange(new vscode.Range(cur, cur)); // make editor scroll to the cursor if outside the screen

  return [target];
}

export function registerSnippetProviderAndCommands(
  context: vscode.ExtensionContext
) {
  // this command will execute insertSnippet operation
  vscode.commands.registerCommand(
    "insertSnippet",
    ({ snippet, startPosition }: IntellisenseCommandArguments) => {
      const endPosition = getActivePosition();
      insertSnippets(snippet, startPosition, endPosition);
    }
  );

  // this command will create a options-intellisense
  vscode.commands.registerCommand(
    "showQuickPick",
    async ({ options = [], snippet, startPosition }: IntellisenseCommandArguments) => {
      const optionsRes =
        (await vscode.window.showQuickPick(options, {
          canPickMany: true,
        })) || [];
      // update variables by options picked items
      for (const option of optionsRes) {
        const { label = "", picked } = option;
        if (picked) {
          // label is a chain connect with '.', access the item step by step
          let obj = snippet.variables || {};
          const keys = label.split(".");
          keys.forEach((key, index) => {
            if (index === keys.length - 1) {
              // last key, access the item
              obj[key] = (option as any).value;
            } else {
              obj[key] = obj[key] || {};
              obj = obj[key];
            }
          });
        }
      }
      const endPosition = getActivePosition();
      insertSnippets(snippet, startPosition, endPosition);
    }
  );

  // this provider will create a search-intellisense
  const completionProvider = vscode.languages.registerCompletionItemProvider(
    ["javascript", "typescript", "javascriptreact", "typescriptreact"],
    {
      provideCompletionItems(document) {
        // get the text from beginning to current cursor
        const start = new vscode.Position(0, 0);
        const end = vscode.window.activeTextEditor?.selection.active;
        const range = new vscode.Range(start, end ?? start);
        const text = document.getText(range);

        return getCompletionItemsByContextText(text);
      },
    },
    "."
  );

  context.subscriptions.push(completionProvider);
}
